===============
Bash Completion
===============

:date: 2014-02-20 22:50
:modified: 2014-02-20 22:50
:tags: coding, bash, autocomplete, python
:category: Programming
:slug: Complex commandline completion in the bash shell
:author: Anthony Roy
:summary: Command line completion can be awkward in bash. Make it easier by shelling out to a more powerful language.
:status: published

Bash completion can be awkward to program in bash. The docs aren't great, and the language esoteric. It would be nice to be able to use your favorite language to do the heavy lifting. This article shows how to achieve this in Python and provides an example of how you can call in to your own application to get the completion data.

The Bash Part
=============

I will start with the bash part of the script. This can be copied replacing just the name of your completion program and the commands to complete. It focuses on getting the important information out of bash completion and into your code.

.. code-block:: bash

    _complete () {
        local cur
    
        cur=${COMP_WORDS[COMP_CWORD]}
        words=`./comp_blog.py "$COMP_CWORD" ${COMP_WORDS[*]}` 
    
        COMPREPLY=( $(compgen -W "${words}" -- ${cur}) )
    }
    
    blog(){
        echo "blog $*"
    }

    complete -F _complete blog
    
The above script is boilerplate code that gets the right values out of the completion variables and sends them through to your script. The arguments passed in are the all of the arguments currently on the commandline. ``cur`` is used by the ``compgen`` function to determine what the current word in the argument list is.

The Python Part
===============

Time for the Python script. This will just implement a multi-level completion where previous terms dictate what future terms look like.

.. code-block:: python

    #!/usr/bin/python
    import sys
    
    options = {
            'add': ['--name', '--date', '--content'],
            'delete': ['--name', '--force']
    }

    commands = options.keys()
    
    index = int(sys.argv[1]) # First argument is the index.
    all = sys.argv[2:]       # All others are the args.
    
    # If the list is shorter than the index of the current word
    # then the current word is empty. Otherwise it is the last 
    # element in the list.
    cur = "" if len(all) <= index else all[index]
    prev = all[index - 1] # Item before the current.
    all = all[1:] # Strip off the command name from the beginning.
    
    if prev not in all:
        # prev must be the command itself. Return subcommands.
        print " ".join(commands)
    else:
        # Find the subcommands already present.
        command_list = [word for word in all if word in commands]
        if command_list:
            # Send back options of latest subcommand.
            opts = options[command_list[-1]]
            print " ".join([opt for opt in opts if opt not in all])
        else:
            # No completions to be had.
            print ""
    
Note that the ``cur`` variable isn't used but is provided in order to illustrate how to get the same value as in the bash script above. The ``all`` variable contains all arguments, stripping out the name of the script (``argv[0]``) and the name of the command being completed (i.e. ``blog`` in this example.) This is a fairly simple multi-level script that has a list of options for the subcommands provided.

More complex scripts could be created - with much more ease and readability than if they had been written in bash. I have written a small command framework in Ruby which uses the Trollop option parser to parse the command line. Using the parser method in Trollop, it is fairly easy to create a program which defines subcommands, where those subcommands provide their own option parser. The Trollop parsers can be queried for the purposes of auto-completion. This may make up a future post.
