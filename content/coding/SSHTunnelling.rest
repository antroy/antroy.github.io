SSH Tunnels - Why and How
=========================

:date: 2014-02-25 20:25
:modified: 2014-02-25 20:25
:tags: coding, ssh
:category: Programming
:slug: SSH Tunnels
:author: Anthony Roy
:summary: How to create tunnels and what to use them for.
:status: draft

Tunnelling is a really useful way to get connectivity to services on other machines where firewall restrictions would otherwise stop you from getting that connectivity. Use cases for this include gaining access to services in test environments from your development machine in order to test your applications against real endpoints or connecting from a laptop over VPN to a desktop machine. The following examples show forward and reverse tunnels and how they can be combined to tunnel from one machine to another via a third that both can access.

SSH Tunnel
----------

The basic command for setting up a tunnel is as follows:

.. code-block:: bash

    ssh -L <local_port>:<destination_host>:<destination_port> <remote_user>@<remote_host>

The following commandline snippets show how you can tunnel through ssh in order to ftp a file onto a remote box and how to access a web port on a remote server locally.

.. code-block:: bash

    ssh -L 1234:ftp_server:21 middleman@188.88.88.88
    ssh -L 80:middleman:8080 middleman@188.88.88.88

In the first example we set up the tunnel through a middleman server (jump host) that we have access to, and that *does* have access to port 21 on ftp_server. We can then ftp to and from ftp_server by connecting the FTP client to port 1234 on our local machine. 

The second example shows how we can expose a port (8080) on a server we have ssh access to locally. This is useful if we have code deployed to a local machine that needs access to a service on a test server, but access restrictions stop us connecting to the relevant port directly. In this case we do have ssh access to the remote server we are trying to access the service on, we just don't have access to the port we need (8080 in this case). The tunnel forwards port 80 on our machine to port 8080 on the test server.

SSH Reverse Tunnel
------------------

Reverse tunnels solve the opposite problem. Your computer is running a version of an API that you are developing, and you want to temporarily point an application on a test server at the API on your computer. Due to the way the networks and firewalls are configured, there is no access from the test server to port 80 on your machine. This is where reverse tunnels come in.

.. code-block:: bash
    
    ssh -R <remote_port>:destination_host:destination_port <remote_user>@<remote_host>

For the above example, this may be something like:

.. code-block:: bash

    ssh -R 1234:localhost:80 sourceuser@jumphost

The above sets up a reverse tunnel from the server jumphost to your local machine using port 1234. This allows you to hook up your remote application to your PC to consume your development endpoint by configuring it to point at port 1234 on jumphost.

Other examples may be to allow you to ssh from one box to another when they are on separate NAT'd networks via a host or hosts available to both over ssh. In such a case you may need a combination of reverse and forward tunnels to provide the connectivity you want. This sort of tunnel chaining can also be used to set up ad hoc VPN's for services - all data over the tunnel is (by nature of being SSH) encrypted.

Dealing with SSH Timeouts
-------------------------

Quite often policy demands that your SSH sessions are configured to time out after a period of inactivity. This is obviously not very useful if you need to set up tunnels. A common technique is to set a program like ``top`` or ``watch "date"`` or similar to keep the session reporting data over the connection and hence keeping the session alive.

If doing something like this, it is a good idea to do so on top of a ``screen`` session, since you can easily then open a new screen if you need to do work on the box you are ssh-ing onto.

Managing Keys
-------------

SSH Keys provide a solution to having to log in to a server with your credentials every time you want to ssh onto a box. The idea is that you generate a private/public key pair and copy the public one onto the servers you want to access. When you ssh onto those machines, the ssh protocol looks up your default key (or uses one you have specified on the command line) and sends it over the wire in place of a password.

Generating a key is simple:

.. code-block:: bash
  
    ssh-keygen

This command will prompt you for a filename for the (private) key, and a passphrase to keep the key secure, and then generates a public/private key pair. The private key should always remain on your machine, but the public key may be copied wherever you need it to be. Github for example requires an ssh key in order for you to connect to it via the git protocol. Note that it is easiest to accept the default key file, as most ssh tools assume that that is where your key is. If you choose to put it elsewhere, you will have to specify the key to the command (typically with the -i option) or set it in your ssh config file (see below).

Enabling key based authentication is simply a matter of adding your public key to the ``~/.ssh/authorized_keys`` file on the server you wish to authenticate on. This should be the text content of the public key on its own line in the ``authorized_keys`` file. A command which makes this very easy is the following:

.. code-block:: bash

    ssh-copy-id user@host

This will put your key in the ``authorized_keys`` file on the host machine - but this time will ask you to provide your password. Subsequent ssh commands will be allowed straight in.

Managing SSH Servers
--------------------

It is hard to remember all of the names or IP addresses of the servers you deal with on a daily basis, so a way of managing them is desirable. This is where the ``~/.ssh/config`` file comes in. It has a pretty simple format:

.. code-block::

    Host dev-box
    HostName lnx07zz01.mydomain
    User antroy
    
    Host prod
    HostName lnx07zz01.mydomain
    User antroy
    IdentityFile ~/.ssh/prod_key
    


